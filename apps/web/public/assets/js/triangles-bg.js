/**
 * osu! Style Triangle Background Animation
 * Generated by Gemini
 * * Usage:
 * initTriangleBackground(document.getElementById('myCanvas'), {
 * triColor: '#42b983',
 * density: 50 // Lower is denser (triangles per X pixels)
 * });
 */

function initTriangleBackground(canvas, userConfig = {}) {
    const ctx = canvas.getContext('2d');

    // Configuration with defaults
    const config = {
        bgColor1: '#1a2e22', // Center gradient color
        bgColor2: '#0d0d0d', // Edge color
        triColor: '#42b983', // Triangle line color
        strokeWidth: 2,
        density: 15000, // Area per triangle (width * height / density). Higher = fewer triangles.
        maxSize: 120, // Max triangle size
        minSize: 20, // Min triangle size
        opacity: 0.15, // Max opacity
        speed: 1, // Vertical drift speed
        ...userConfig
    };

    let triangles = [];
    let animationId;
    let w, h;

    // Helper: Draw a single triangle
    function drawTriangle(t) {
        const height = t.size * (Math.sqrt(3) / 2);

        ctx.save();
        ctx.beginPath();
        ctx.translate(t.x, t.y);

        ctx.moveTo(0, -height / 2);
        ctx.lineTo(-t.size / 2, height / 2);
        ctx.lineTo(t.size / 2, height / 2);
        ctx.closePath();

        ctx.lineWidth = config.strokeWidth;
        ctx.strokeStyle = config.triColor;
        ctx.globalAlpha = t.opacity * config.opacity;
        ctx.stroke();
        ctx.restore();
    }

    // Helper: Initialize or Re-initialize triangles
    function initTriangles() {
        triangles = [];
        // Calculate count based on screen area so density looks consistent on mobile vs desktop
        const count = Math.floor((w * h) / config.density);

        for (let i = 0; i < count; i++) {
            triangles.push({
                x: Math.random() * w,
                y: Math.random() * h,
                size: Math.random() * (config.maxSize - config.minSize) + config.minSize,
                opacity: Math.random() * 0.9 + 0.1, // Relative opacity factor
                speedVariance: Math.random() * 0.5 + 0.5
            });
        }
    }

    // Main Animation Loop
    function animate() {
        ctx.clearRect(0, 0, w, h);

        // 1. Draw Background (Radial Gradient)
        // Center the gradient slightly above true center (h/3) for a "spotlight" feel
        const gradient = ctx.createRadialGradient(w / 2, h / 3, 0, w / 2, h / 2, Math.max(w, h));
        gradient.addColorStop(0, config.bgColor1);
        gradient.addColorStop(1, config.bgColor2);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        // 2. Draw & Update Triangles
        triangles.forEach(t => {
            t.y -= t.speedVariance * config.speed;

            // Reset if off screen (fully above top edge)
            const triangleHeight = t.size * 0.866; // approx sqrt(3)/2
            if (t.y + triangleHeight < -50) {
                t.y = h + 50;
                t.x = Math.random() * w;
            }

            drawTriangle(t);
        });

        animationId = requestAnimationFrame(animate);
    }

    // Handle Resize
    function resize() {
        // Measure the parent element instead of the whole window so the canvas fits its container
        const parent = canvas.parentElement || document.body;
        const rect = parent.getBoundingClientRect();

        // Use CSS pixels for logical width/height and scale the backing store for devicePixelRatio
        const cssWidth = Math.max(0, rect.width);
        const cssHeight = Math.max(0, rect.height);
        const dpr = Math.max(1, window.devicePixelRatio || 1);

        // Ensure the canvas displays at the correct CSS size
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';

        // Set the internal resolution to match device pixels for crisp rendering
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);

        // Store logical sizes (in CSS pixels) used for layout/density calculations
        w = cssWidth;
        h = cssHeight;

        // Reset any transforms and scale drawing operations so 1 unit == 1 CSS pixel
        // Using setTransform clears previous scale so repeated calls are safe
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Re-init triangles to adjust density for the new size
        initTriangles();
    }

    // Debounced resize handler (uses rAF to avoid thrashing during continuous resize)
    let resizeRaf = null;
    function onResize() {
        if (resizeRaf) cancelAnimationFrame(resizeRaf);
        resizeRaf = requestAnimationFrame(() => {
            resize();
            resizeRaf = null;
        });
    }

    // Start everything
    window.addEventListener('resize', onResize);
    resize(); // Trigger initial size calc
    animate();

    // Return cleanup function if needed (e.g. for React useEffect)
    return () => {
        window.removeEventListener('resize', onResize);
        if (resizeRaf) cancelAnimationFrame(resizeRaf);
        cancelAnimationFrame(animationId);
    };
}
